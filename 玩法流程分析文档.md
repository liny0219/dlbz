# 玩法流程分析文档

## 概述

本文档详细分析了项目中所有玩法模式的业务流程，包括时序图、流程图和关键业务逻辑。这些分析结果将作为后续优化的参考基准，确保在优化过程中不会破坏核心业务逻辑。

## 1. 逢魔玩法流程

### 1.1 状态机设计

逢魔模式使用8个状态来管理整个流程：

```python
class Step(Enum):
    UN_START = 0      # 未开始
    FINISH = 1        # 完成
    COLLECT_JUNK = 2  # 收集杂物阶段
    FIND_BOX = 3      # 寻找宝箱/怪物/治疗点阶段
    FIND_BOSS = 4     # 寻找Boss阶段
    FIGHT_BOSS = 5    # 战斗Boss阶段
    BATTLE_FAIL = 6   # 战斗失败
    State_FAIL = 7    # 状态失败
```

### 1.2 时序图

```mermaid
sequenceDiagram
    participant Main as 主线程
    participant AppThread as App监控线程
    participant CheckThread as 信息检查线程
    participant World as 世界模块
    participant Battle as 战斗模块
    participant Device as 设备管理

    Main->>AppThread: 启动App监控
    Main->>CheckThread: 启动信息检查
    Main->>World: 设置怪物配置
    
    loop 主循环
        Main->>Main: 报告统计数据
        Main->>World: 检查休息需求
        Main->>World: 进入逢魔地图
        
        Main->>Main: 开始新轮次
        Main->>Main: 设置状态为COLLECT_JUNK
        
        alt 收集杂物阶段
            Main->>World: 遍历检查点
            Main->>Device: 打开小地图
            Main->>Device: 点击检查点位置
            Main->>World: 查找逢魔点
            Main->>Device: 点击逢魔点
            CheckThread->>CheckThread: 检测状态变化
        end
        
        alt 寻找宝箱阶段
            Main->>World: 打开小地图
            Main->>Device: 查找地图标签
            Main->>Device: 点击最近点位
            Main->>World: 轮询配置点位
            CheckThread->>CheckThread: 检测发现事件
        end
        
        alt Boss战阶段
            Main->>World: 打开小地图
            Main->>World: 查找Boss点
            Main->>Device: 点击Boss点
            Main->>World: 查找Boss逢魔点
            Main->>Device: 点击Boss逢魔点
            Battle->>Battle: 执行Boss战
        end
        
        Main->>Main: 结束轮次统计
    end
```

### 1.3 流程图

```mermaid
flowchart TD
    A[开始] --> B[初始化状态数据]
    B --> C[启动监控线程]
    C --> D[设置怪物配置]
    D --> E[主循环开始]
    
    E --> F[报告统计数据]
    F --> G{需要休息?}
    G -->|是| H[VIP治疗检查]
    H --> I{治疗完成?}
    I -->|否| J[旅馆休息]
    I -->|是| K[跳过休息]
    G -->|否| K
    J --> K
    
    K --> L[进入逢魔地图]
    L --> M[开始新轮次]
    M --> N[设置状态: COLLECT_JUNK]
    
    N --> O[收集杂物阶段]
    O --> P{遍历检查点}
    P --> Q[打开小地图]
    Q --> R[点击检查点]
    R --> S[查找逢魔点]
    S --> T{找到逢魔点?}
    T -->|是| U[点击逢魔点]
    T -->|否| V[下一个检查点]
    U --> W{状态变化?}
    W -->|是| X[退出收集阶段]
    W -->|否| V
    V --> P
    
    X --> Y[设置状态: FIND_BOX]
    Y --> Z[寻找宝箱阶段]
    Z --> AA[打开小地图]
    AA --> BB[查找地图标签]
    BB --> CC[点击最近点位]
    CC --> DD[轮询配置点位]
    DD --> EE{状态变化?}
    EE -->|是| FF[退出寻找阶段]
    EE -->|否| DD
    
    FF --> GG[设置状态: FIND_BOSS]
    GG --> HH[Boss战阶段]
    HH --> II[打开小地图]
    II --> JJ[查找Boss点]
    JJ --> KK[点击Boss点]
    KK --> LL[查找Boss逢魔点]
    LL --> MM[点击Boss逢魔点]
    MM --> NN[执行Boss战]
    NN --> OO{战斗结果}
    OO -->|成功| PP[设置状态: FINISH]
    OO -->|失败| QQ[设置状态: BATTLE_FAIL]
    
    PP --> RR[轮次成功统计]
    QQ --> SS[轮次失败统计]
    RR --> E
    SS --> E
```

### 1.4 关键业务逻辑

#### 收集杂物阶段 (`_collect_junk_phase`)
1. **检查点遍历**: 按顺序遍历配置的检查点
2. **小地图操作**: 打开小地图，点击检查点位置
3. **逢魔点查找**: 在当前区域查找逢魔点
4. **状态检查**: 检查是否在城镇中或遇到战斗
5. **回退机制**: 遇到战斗时回退到上一个检查点

#### 寻找宝箱阶段 (`_find_box_phase`)
1. **地图标签识别**: 识别小地图上的宝箱、怪物、治疗点标签
2. **最近点位计算**: 计算距离最近的检查点
3. **点位轮询**: 按配置顺序点击各个点位
4. **状态监控**: 监控是否发现目标

#### Boss战阶段 (`_find_boss_phase`)
1. **Boss点查找**: 在小地图上查找Boss点
2. **Boss逢魔点**: 查找Boss的逢魔点
3. **战斗执行**: 执行Boss战斗
4. **结果处理**: 处理战斗结果

### 1.5 线程协作机制

#### 主线程职责
- 流程控制和状态管理
- 设备操作和点击
- 统计数据处理

#### 子线程职责
- App存活监控
- 屏幕信息检查
- 状态变化检测

#### 线程安全机制
- 截图缓存管理
- 状态数据安全访问
- 资源清理机制

## 2. 刷野玩法流程

### 2.1 状态设计

刷野模式使用简单的状态切换：

```python
@dataclass
class FarmingStateData:
    app_alive: bool = False
    in_map: bool = False
    battle_count: int = 0
    last_time: float = 0
```

### 2.2 时序图

```mermaid
sequenceDiagram
    participant Main as 主线程
    participant World as 世界模块
    participant Battle as 战斗模块
    participant Device as 设备管理

    Main->>Main: 初始化状态数据
    
    loop 刷野循环
        Main->>Device: 获取截图
        Main->>World: 检查世界/战斗状态
        
        alt 在战斗中
            World-->>Main: 返回in_battle
            Main->>Battle: 自动战斗
        end
        
        alt 在城镇中
            World-->>Main: 返回in_world
            Main->>Main: 更新战斗计数
            Main->>World: 左右跑动
        end
        
        alt 状态未知
            World-->>Main: 返回None
            Main->>World: 继续跑动或点击确认
        end
        
        Main->>Main: 报告统计数据
    end
```

### 2.3 流程图

```mermaid
flowchart TD
    A[开始刷野] --> B[初始化状态数据]
    B --> C[获取截图]
    C --> D[检查世界/战斗状态]
    
    D --> E{状态判断}
    E -->|在战斗中| F[自动战斗]
    E -->|在城镇中| G[更新战斗计数]
    E -->|状态未知| H{前一个状态}
    
    F --> I[继续循环]
    G --> J[左右跑动]
    H -->|在城镇中| K[继续跑动]
    H -->|在战斗中| L[点击确认]
    
    J --> M[报告统计数据]
    K --> M
    L --> M
    M --> I
    I --> C
```

### 2.4 关键业务逻辑

1. **状态检测**: 通过截图分析判断当前状态
2. **自动战斗**: 在战斗中自动执行战斗流程
3. **跑动机制**: 在城镇中左右跑动寻找敌人
4. **计数统计**: 记录战斗次数和挂机时间

## 3. 日常玩法流程

### 3.1 功能设计

日常模式支持花田和果炎两个功能：

```python
# 配置参数
huatian_enabled: bool = False
huatian1_enabled: bool = False
huatian2_enabled: bool = False
guoyan_enabled: bool = False
```

### 3.2 时序图

```mermaid
sequenceDiagram
    participant Main as 主线程
    participant World as 世界模块
    participant OCR as OCR识别
    participant Device as 设备管理

    Main->>Main: 检查配置参数
    
    alt 花田功能启用
        Main->>World: 检查应用状态
        Main->>World: 传送到无名小镇
        Main->>World: 导航到花田位置
        
        loop 花田1循环
            Main->>Device: 获取截图
            Main->>OCR: 识别花田1目标
            OCR-->>Main: 返回识别结果
            Main->>Device: 点击目标位置
        end
        
        loop 花田2循环
            Main->>Device: 获取截图
            Main->>OCR: 识别花田2目标
            OCR-->>Main: 返回识别结果
            Main->>Device: 点击目标位置
        end
    end
    
    alt 果炎功能启用
        Main->>World: 导航到果炎位置
        
        loop 果炎循环
            Main->>Device: 获取截图
            Main->>OCR: 识别果炎目标
            OCR-->>Main: 返回识别结果
            Main->>Device: 点击目标位置
        end
    end
```

### 3.3 流程图

```mermaid
flowchart TD
    A[开始日常玩法] --> B[检查配置参数]
    B --> C{花田功能启用?}
    C -->|是| D[执行花田功能]
    C -->|否| E[跳过花田]
    
    D --> F[检查应用状态]
    F --> G[传送到无名小镇]
    G --> H[导航到花田位置]
    
    H --> I{花田1启用?}
    I -->|是| J[花田1循环]
    I -->|否| K[跳过花田1]
    
    J --> L[获取截图]
    L --> M[识别花田1目标]
    M --> N{找到目标?}
    N -->|是| O[点击目标位置]
    N -->|否| P[等待重试]
    O --> Q{达到目标次数?}
    Q -->|否| L
    Q -->|是| R[花田1完成]
    P --> L
    
    K --> S{花田2启用?}
    S -->|是| T[花田2循环]
    S -->|否| U[跳过花田2]
    
    T --> V[获取截图]
    V --> W[识别花田2目标]
    W --> X{找到目标?}
    X -->|是| Y[点击目标位置]
    X -->|否| Z[等待重试]
    Y --> AA{达到目标次数?}
    AA -->|否| V
    AA -->|是| BB[花田2完成]
    Z --> V
    
    R --> S
    U --> CC{果炎功能启用?}
    CC -->|是| DD[执行果炎功能]
    CC -->|否| EE[跳过果炎]
    
    DD --> FF[导航到果炎位置]
    FF --> GG[果炎循环]
    GG --> HH[获取截图]
    HH --> II[识别果炎目标]
    II --> JJ{找到目标?}
    JJ -->|是| KK[点击目标位置]
    JJ -->|否| LL[等待重试]
    KK --> MM{达到目标次数?}
    MM -->|否| HH
    MM -->|是| NN[果炎完成]
    LL --> HH
    
    E --> CC
    BB --> CC
    EE --> OO[日常玩法完成]
    NN --> OO
```

### 3.4 关键业务逻辑

1. **OCR识别**: 使用OCR技术识别屏幕上的目标
2. **目标点击**: 根据识别结果点击目标位置
3. **循环控制**: 根据配置的目标次数控制循环
4. **调试支持**: 保存OCR截图用于调试

## 4. 战斗测试流程

### 4.1 功能设计

战斗测试模式用于测试战斗脚本：

```python
class BattleTestMode:
    def __init__(self, device_manager, ocr_handler, log_queue=None, battle_script_path=None):
        self.test_count = 0
        self.success_count = 0
        self.fail_count = 0
```

### 4.2 时序图

```mermaid
sequenceDiagram
    participant Main as 主线程
    participant World as 世界模块
    participant Battle as 战斗模块
    participant Executor as 战斗执行器

    Main->>Main: 验证脚本文件
    Main->>Executor: 加载战斗指令
    Executor-->>Main: 返回加载结果
    
    alt 单次测试
        Main->>Executor: 执行所有指令
        Executor-->>Main: 返回执行结果
        Main->>Main: 更新统计数据
    end
    
    alt 多次测试
        loop 测试次数
            Main->>Executor: 执行所有指令
            Executor-->>Main: 返回执行结果
            Main->>Main: 更新统计数据
            Main->>Main: 等待间隔
        end
    end
    
    Main->>Main: 报告测试结果
```

### 4.3 流程图

```mermaid
flowchart TD
    A[开始战斗测试] --> B[验证脚本文件]
    B --> C{文件有效?}
    C -->|否| D[测试失败]
    C -->|是| E[加载战斗指令]
    
    E --> F{加载成功?}
    F -->|否| G[测试失败]
    F -->|是| H{测试类型}
    
    H -->|单次测试| I[执行战斗指令]
    H -->|多次测试| J[多次测试循环]
    
    I --> K{执行成功?}
    K -->|是| L[更新成功统计]
    K -->|否| M[更新失败统计]
    
    J --> N[执行战斗指令]
    N --> O{执行成功?}
    O -->|是| P[更新成功统计]
    O -->|否| Q[更新失败统计]
    P --> R{达到测试次数?}
    Q --> R
    R -->|否| S[等待间隔]
    S --> N
    R -->|是| T[测试完成]
    
    L --> U[报告测试结果]
    M --> U
    T --> U
    D --> U
    G --> U
```

### 4.4 关键业务逻辑

1. **脚本验证**: 检查战斗脚本文件的有效性
2. **指令加载**: 将脚本指令加载到执行器
3. **执行测试**: 执行战斗指令并记录结果
4. **统计报告**: 统计成功率和失败率

## 5. 追忆之书流程

### 5.1 功能设计

追忆之书模式实现阅读和战斗循环：

```python
class MemoryMode:
    def __init__(self, device_manager, ocr_handler, log_queue=None):
        self.total_battles = 0
        self.is_running = False
```

### 5.2 时序图

```mermaid
sequenceDiagram
    participant Main as 主线程
    participant World as 世界模块
    participant Battle as 战斗模块
    participant Executor as 战斗执行器
    participant Device as 设备管理

    Main->>Main: 验证脚本文件
    Main->>Executor: 加载战斗脚本
    
    loop 战斗次数
        Main->>Device: 点击阅读按钮
        Main->>Device: 确认阅读
        Main->>Battle: 等待战斗开始
        Main->>Executor: 执行战斗脚本
        Main->>Battle: 检查战斗状态
        Main->>Battle: 退出战斗
        Main->>Main: 等待战斗结果
        Main->>Main: 更新统计数据
    end
    
    Main->>Main: 报告最终统计
```

### 5.3 流程图

```mermaid
flowchart TD
    A[开始追忆之书] --> B[验证脚本文件]
    B --> C{文件有效?}
    C -->|否| D[执行失败]
    C -->|是| E[加载战斗脚本]
    
    E --> F{加载成功?}
    F -->|否| G[执行失败]
    F -->|是| H{达到战斗次数?}
    
    H -->|否| I[点击阅读按钮]
    I --> J[确认阅读]
    J --> K[等待战斗开始]
    K --> L[执行战斗脚本]
    L --> M[检查战斗状态]
    M --> N{在战斗中?}
    N -->|是| O[退出战斗]
    N -->|否| P[等待战斗结果]
    O --> P
    P --> Q[更新统计数据]
    Q --> R[增加战斗计数]
    R --> H
    
    H -->|是| S[报告最终统计]
    D --> S
    G --> S
```

### 5.4 关键业务逻辑

1. **阅读操作**: 点击阅读按钮并确认
2. **战斗执行**: 执行配置的战斗脚本
3. **状态检查**: 检查战斗状态并处理
4. **循环控制**: 根据配置的战斗次数控制循环

## 6. 共同设计模式

### 6.1 依赖注入模式

所有玩法模式都使用相同的依赖注入方式：

```python
def __init__(self, device_manager: DeviceManager, ocr_handler: OCRHandler, log_queue=None):
    self.device_manager = device_manager
    self.ocr_handler = ocr_handler
    self.app_manager = AppManager(device_manager)
    self.battle = Battle(device_manager, ocr_handler, self.app_manager)
    self.world = World(device_manager, ocr_handler, self.battle, self.app_manager)
```

### 6.2 状态管理模式

每个模式都有明确的状态数据管理：

```python
# 逢魔模式
@dataclass
class StateData:
    step: Step = Step.COLLECT_JUNK
    current_point: CheckPoint|None = None
    # ... 其他状态数据

# 刷野模式
@dataclass
class FarmingStateData:
    app_alive: bool = False
    in_map: bool = False
    battle_count: int = 0
```

### 6.3 异常处理模式

所有模式都有完整的异常处理机制：

```python
try:
    # 主要业务逻辑
    pass
except Exception as e:
    logger.error(f"发生异常: {e}")
    # 异常恢复逻辑
finally:
    # 清理资源
    self.cleanup()
```

### 6.4 统计报告模式

所有模式都有数据收集和报告功能：

```python
def report_data(self):
    # 收集统计数据
    # 发送到主进程GUI
    if self.log_queue:
        self.log_queue.put("REPORT_DATA__" + report_str)
```

## 7. 业务逻辑保护清单

### 7.1 不能修改的核心逻辑

#### 逢魔模式
- **Step枚举**: 不能修改状态定义和转换逻辑
- **三阶段流程**: 收集杂物 → 寻找宝箱 → Boss战的顺序不能改变
- **检查点遍历**: 按配置顺序遍历检查点的逻辑
- **回退机制**: 遇到战斗时回退到上一个检查点的逻辑
- **状态检查**: 在城镇中break和遇敌战斗回退的逻辑

#### 刷野模式
- **状态检测**: 通过截图分析判断状态的逻辑
- **跑动机制**: 左右跑动寻找敌人的逻辑
- **战斗计数**: 战斗次数的统计逻辑

#### 日常模式
- **OCR识别**: 使用OCR识别目标的逻辑
- **目标点击**: 根据识别结果点击的逻辑
- **循环控制**: 根据目标次数控制循环的逻辑

#### 战斗测试模式
- **脚本验证**: 检查脚本文件有效性的逻辑
- **指令执行**: 执行战斗指令的逻辑
- **结果统计**: 统计成功率和失败率的逻辑

#### 追忆之书模式
- **阅读操作**: 点击阅读按钮和确认的逻辑
- **战斗执行**: 执行战斗脚本的逻辑
- **循环控制**: 根据战斗次数控制循环的逻辑

### 7.2 可以优化的部分

1. **代码结构**: 可以重构代码结构，提高可读性
2. **性能优化**: 可以优化内存使用和响应性能
3. **错误处理**: 可以改进错误处理和日志记录
4. **配置管理**: 可以改进配置管理和验证
5. **测试覆盖**: 可以添加更多的测试用例

### 7.3 优化边界

- ✅ 可以优化代码结构和性能
- ✅ 可以改进错误处理和日志记录
- ✅ 可以添加新的功能和配置选项
- ❌ 不能改变核心的业务流程和状态转换
- ❌ 不能破坏线程安全机制
- ❌ 不能移除关键的异常恢复机制

## 8. 总结

本文档详细分析了项目中所有玩法模式的业务流程，包括：

1. **逢魔模式**: 最复杂的玩法，包含8个状态阶段和完整的三阶段流程
2. **刷野模式**: 简单的状态切换循环，主要依赖截图分析
3. **日常模式**: 基于OCR识别的目标点击功能
4. **战斗测试模式**: 脚本执行测试，相对独立
5. **追忆之书模式**: 阅读和战斗的简单循环

所有模式都遵循相同的设计模式：
- 依赖注入模式
- 状态管理模式
- 异常处理模式
- 统计报告模式

这些分析结果将作为后续优化的参考基准，确保在优化过程中不会破坏核心业务逻辑。任何优化都必须保持业务逻辑的一致性，特别是逢魔模式的复杂状态机和流程控制逻辑。 